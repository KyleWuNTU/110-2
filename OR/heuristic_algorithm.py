# -*- coding: utf-8 -*-
"""Kyle_Algorithm_Class.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-iEmbpPx_SjT1iRF_tR_knMIgU1Bj4D-
"""

!gdown --id 1Lgk3uvfXX8-sK_Ub6-FFKHs35PEyF1kn --output "instance_1.csv"
!gdown --id 1-GUM9dvuHuQ6HQEnVTIknq4NWuMGP38W --output "instance_2.csv" 
!gdown --id 1BAxsBxn3jvJkD3IJ1XkwCLHH4i7P8nVM --output "instance_3.csv"
!gdown --id 1rbRpHa1BM4Ub2ZRj0X9J13i3hUidvkhR --output "instance_4.csv" 
!gdown --id 1Bd-CZe3EhphHBoq_x2gibnrlbIAaFuRl --output "instance_5.csv"

import numpy as np
import pandas as pd
import csv

ins1 = pd.read_csv("instance_1.csv")
ins2 = pd.read_csv("instance_2.csv")
ins3 = pd.read_csv("instance_3.csv")
ins4 = pd.read_csv("instance_4.csv")
ins5 = pd.read_csv("instance_5.csv")

#Sort by Due
class Algorithm:
  def __init__(self, instance):
    self.one_pt = instance["Stage-1 Processing Time"].to_numpy()
    self.two_pt = instance["Stage-2 Processing Time"].to_numpy()
    self.one_m = instance["Stage-1 Machines"].to_numpy()
    self.two_m = instance["Stage-2 Machines"].to_numpy()
    self.due = instance["Due Time"].to_numpy()
    jobs = instance["Job ID"].to_numpy()

    self.machine = {} # used to record the machines that each process of job belongs to
    self.completion_time = {} # used to record the completion time of each jobs

    self.machine_time = {} # used to record the already used time of machines
    self.one_pt_dict = {} # processing time of process one of each job 
    self.two_pt_dict = {}# processing time of process two of each job
    self.machine_list = [] # what are the available machines e.g.[1,2,3,4,5]
    self.one_m_dict = {} # each process one of the job is able to assign to which machines e.g.{"1":[2,3,4,5],"2":[2,3,4]}
    self.two_m_dict = {} # each process two of the job is able to assign to which machines
    self.single_process_jobs = [] #which jobs are the single process jobs -> list e.g.[6,12]
    self.J = len(jobs)

    for i in range(len(self.one_m)):
      self.one_m_dict[i+1] = []
      if type(self.one_m[i]) != float:
        for e in self.one_m[i]:
          if e != ",":
            self.one_m_dict[i+1].append(int(e))
            if (int(e) not in self.machine_list):
              self.machine_list.append(int(e))
            
    for j in range(len(self.two_m)):
      self.two_m_dict[j+1] = []
      if type(self.two_m[j]) != float:
        for e in self.two_m[j]:
          if e != ",":
            self.two_m_dict[j+1].append(int(e))
            if (int(e) not in self.machine_list):
              self.machine_list.append(int(e))
      else:
        self.single_process_jobs.append(j+1)

    for m in range(len(self.machine_list)):
      self.machine_time[m+1] = 0

    for j in range(self.J):
      self.machine[j+1] = []
      self.completion_time[j+1] = []
      self.one_pt_dict[j+1] = self.one_pt[j]
      self.two_pt_dict[j+1] = self.two_pt[j]

  # Grouping jobs with close due_time (due_interval)
  def grouping_jobs(self):
    due_interval = [0,4,8,12,14,16,20,24] #use interval instead of absolute value {4:[...],8:[...],12:[...]}
    intervalize_due = []
    for i in self.due:
      closeness = 999999
      close_j = 0
      for j in due_interval:
        if abs(i-j) < closeness:
          closeness = abs(i-j)
          close_j = j
      intervalize_due.append(close_j)

    sorted_due_index = np.argsort(intervalize_due) 
    self.grouping ={}
    container = []
    for i in range(len(sorted_due_index)):
      if i+1 < len(sorted_due_index) and intervalize_due[sorted_due_index[i]] == intervalize_due[sorted_due_index[i+1]]:
        container.append(sorted_due_index[i]+1)
      else:
        container.append(sorted_due_index[i]+1)
        self.grouping[intervalize_due[sorted_due_index[i]]] = container
        container = []

    #if the job is overdue at the begining we place it to the last
    self.grouping[9999999] = []
    for key in self.grouping:
      remove_cnt = 0
      for job in range(len(self.grouping[key])):
        if self.due[self.grouping[key][job]-1] < (self.one_pt_dict[self.grouping[key][job]] + self.two_pt_dict[self.grouping[key][job]]):
          self.grouping[max].append(self.grouping[key][job])
          self.grouping[key][job] = 0
          remove_cnt += 1

      for zeros in range(remove_cnt):
        self.grouping[key].remove(0)


    #Use available machines to process as order to produce for the same category of due-time
    process_jobs_machines_available = {}
    for key in self.one_m_dict:
        process_jobs_machines_available[key] = len(self.one_m_dict[key])

    for key in self.two_m_dict:
        process_jobs_machines_available[key] += len(self.two_m_dict[key])
    
    
    #Order the subset by available machine number (for only two process job)
    for key in self.grouping:
      reference = []
      for job in self.grouping[key]:
        reference.append(process_jobs_machines_available[job])
      self.grouping[key] = [x for _,x in sorted(zip(reference,self.grouping[key]))] #sort grouping[key] according to reference
      self.grouping[key] = [self.grouping[key]]

    #append single process job
    for key in self.grouping:
      self.grouping[key].append([])
      remove_cnt = 0
      for job in range(len(self.grouping[key][0])):
        if self.grouping[key][0][job] in self.single_process_jobs:
          self.grouping[key][1].append(self.grouping[key][0][job])
          self.grouping[key][0][job] = 0
          remove_cnt += 1

      for zeros in range(remove_cnt):
        self.grouping[key][0].remove(0)

    #Show dictionaries
    #print("grouping",self.grouping)  # {5: [[7, 1, 2, 3, 4, 5], [6]], 10: [[8, 9, 10, 11], [12]]} For due time = 5, the two-stage-process jobs are [7, 1, 2, 3, 4, 5], the one-stage-process jobs are [6]

  #start assigning jobs to machines
  #one_pt, two_pt need to use x-1 index because they are lists

  def machines_todo_first_stage(self, job): # find available machine to due with the first stage of the job
    tmp = 9999999
    for m in self.one_m_dict[job]:
      if self.machine_time[m] < tmp:
        least_m = m
        tmp = self.machine_time[m]
    return least_m

  def machines_todo_second_stage(self, job):  #if add the second stage will not overdue, we pick the one with minimum gap 
    min_machine = 0
    least_m = 0
    minimum_gap = 999999
    minimum_machine_time = 999999

    for m in self.two_m_dict[job]:
      if type(self.completion_time[job]) != list:
        gap = self.machine_time[m] - self.completion_time[job]
      else:
        gap = self.machine_time[m] - self.completion_time[job][0]

      if gap == 0:
        return m, gap

      elif gap > 0 and self.machine_time[m] < minimum_machine_time:
        min_machine = m
        minimum_machine_time = self.machine_time[m]
        min_machine_gap = gap

      elif gap < 0 and abs(gap) < abs(minimum_gap):
        least_m = m
        minimum_gap = gap

    if min_machine != 0:
      return min_machine, min_machine_gap
    else:
      return least_m, minimum_gap

    
  def jobs_allocation(self):
    for key in self.grouping: #allocates by the order
      for stage_one_job in self.grouping[key][0]: #allocate the first process of the job
        m = self.machines_todo_first_stage(stage_one_job)
        self.machine_time[m] += self.one_pt_dict[stage_one_job]
        self.machine[stage_one_job].append(m)
        self.completion_time[stage_one_job].append(self.machine_time[m])

      for stage_two_job in self.grouping[key][0]: #allocate the second process of the job
        m, gap = self.machines_todo_second_stage(stage_two_job)
        if gap < 0:
          self.machine_time[m] += float((self.two_pt_dict[stage_two_job] + abs(gap)))
        else:
          self.machine_time[m] += float(self.two_pt_dict[stage_two_job])
        self.machine[stage_two_job].append(m)
        self.completion_time[stage_two_job].append(self.machine_time[m])
      
      for single_p_job in self.grouping[key][1]: #allocate the single process job
        m = self.machines_todo_first_stage(single_p_job)
        self.machine_time[m] += self.one_pt_dict[single_p_job]
        self.machine[single_p_job].append(m)
        self.completion_time[single_p_job].append(self.machine_time[m])

    #final fix up for the rounding
    for keys in self.machine_time:
      self.machine_time[keys] = round(self.machine_time[keys],2)
    for keys in self.completion_time:
      for time in range(len(self.completion_time[keys])):
        self.completion_time[keys][time] =round(self.completion_time[keys][time],2)

def performance_evaluation(completion_time, machine_time, due):
  # Calculate tardy jobs and make span
  tardy_jobs = 0
  makespan = 0
  for key in completion_time:
    if len(completion_time[key]) == 2 and completion_time[key][1] >= due[key-1]:
      tardy_jobs += 1
    elif len(completion_time[key]) == 1 and completion_time[key][0] >= due[key-1]:
      tardy_jobs += 1

  for key in machine_time:
    if machine_time[key] > makespan:
      makespan = machine_time[key]

  print(tardy_jobs)
  print(makespan)

algo = Algorithm(ins5)
algo.grouping_jobs()
algo.jobs_allocation()

due = algo.due
machine_dict = algo.machine
machine_time = algo.machine_time
completion_time_dict = algo.completion_time

print(algo.machine_time)
print(machine_dict)
print(completion_time_dict)

performance_evaluation(completion_time_dict, machine_time, due)

for keys in machine_dict:
  if len(machine_dict[keys]) == 1:
    machine_dict[keys].append(0)

for keys in completion_time_dict:
  if len(completion_time_dict[keys]) == 1:
    completion_time_dict[keys].append(0)

machine = []
completion_time = []

for keys in machine_dict:
  machine.append(machine_dict[keys])
  completion_time.append(completion_time_dict[keys])

print(machine)
print(completion_time)

"""#Job sort by space"""

